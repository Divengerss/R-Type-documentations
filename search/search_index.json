{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"R-Type Networked"},{"location":"#overview","title":"Overview","text":"<p>R-Type is a horizontally scrolling shooter arcade video game developed and released by Irem in 1987 and the first game in the R-Type series. The player controls a star ship, the R-9 \"Arrowhead\", in its efforts to destroy the Bydo, a powerful alien race bent on wiping out all of mankind.</p> <p>Source: Wikipedia</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation process uses vcpkg to install its depedencies.</p> <p>We provided Installation scripts to help you install everything.</p> <p>Simply run <code>install.sh</code> on Linux or <code>install.bat</code> on Windows.</p> <p>To compile the programs <code>r-type_client</code> and <code>r-type_server</code>:</p> <pre><code>  $&gt; cmake -S . -B Build/\n  $&gt; make -C Build/ -j\n</code></pre> <p>Note: Make sure you are under the root directory before running the compilation commands.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<p>Both programs use C++</p> <p>Client: SFML</p> <p>Server: Asio</p> <p>Note: Has it is required to communicate with the server, the client also uses Asio.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentations can be found here</p>"},{"location":"#license","title":"License","text":""},{"location":"#authors","title":"Authors","text":"<ul> <li>@Divengerss</li> <li>@M4KS0U</li> <li>@JulianEmr</li> <li>@JulesLevi</li> </ul>"},{"location":"Server/Protocol/binary_protocol/","title":"Binary protocol","text":"<p>Communication between the server and the players/clients is done using binary packets.</p> <p>A packet on its own contains a header and its data to transmit. The header contains the type of packet sent and the size of the following data. By default (if unchanged in the code) the packet size locally is limited to 1024 bytes.</p> <p>Here is the packet header structure defined in the Packet.hpp</p> <pre><code>struct packetHeader\n{\n    packetTypes type;\n    std::uint16_t dataSize;\n\n    packetHeader() : type(PLACEHOLDER), dataSize(0) {}\n    packetHeader(packetTypes type, std::uint16_t dataSize) : type(type), dataSize(dataSize) {}\n};\n</code></pre> <p>This can be interpreted as the following pseudo-code</p> <pre><code>HEADER\n{\n    INTEGER type\n    16BIT UNSIGNED INTEGER size_of_the_data\n}\n</code></pre> <p>The <code>packetTypes type</code> refers to the following <code>Enum</code></p> <pre><code>enum packetTypes\n{\n    PLACEHOLDER,\n    CONNECTION_REQUEST,\n    DISCONNECTION_REQUEST,\n};\n</code></pre> <p>The <code>std::uint16_t dataSize</code> stores an unsigned 16bits integer refering to the packet data size to be read from the recipient. Data must be strictly identical to the data size, if the value if lower than its actual size, it will be truncated, leading to undefined behavior. If the value is greather than its actual size, it will mostly crash or leads to buffer overflow, leading to undefined behavior. If the type is set to <code>PLACEHOLDER</code>, no data is expected to be read, setting the <code>dataSize</code> to 0.</p> <p>Packet header contains contructors to initialize the header with given values.</p> <p>Packet lists:</p> <ul> <li>Connection request</li> <li>Disconnection request</li> </ul>"},{"location":"Server/Protocol/Packets/connection_request/","title":"Connection request","text":"<p>Type <code>CONNECTION_REQUEST</code></p> <pre><code>struct connectionRequest\n{\n    std::uint8_t status;\n    std::array&lt;std::uint8_t, UUID_SIZE&gt; uuid;\n\n    connectionRequest() : status(REQUEST)\n    {\n        std::memset(&amp;uuid, 0, UUID_SIZE);\n    }\n    connectionRequest(uint8_t status, const std::string &amp;cliUuid) : status(status)\n    {\n        std::memcpy(&amp;uuid, cliUuid.data(), UUID_SIZE);\n    }\n};\n</code></pre> <p>The connection request packet asks the server if the client can connect to the server. The client is not expected to provide anything upon sending the packet, however, the packet type must be revelant in the header.</p> <p>The <code>std::uint8_t status</code> refers to the server response and so, doesn't need to be set from the client. The server will response with <code>ACCEPTED</code> anyway, as the connection will always be valid, even if the client is already connected to the server. It is the client job to check if he already has an open connection with the server.</p> <p>When receiving the packet response from the server, the <code>dataSize</code> should be set to <code>UUID_SIZE</code>, or 37 bits (is unchanged in the code) containing the UUID the client holds on the server. This Universally Unique Identifier must be used from now to send any packets to the server, if no UUID are provided, the server will refuse them.</p> <p>The UUID represent a string as follow: <code>XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code></p>"}]}