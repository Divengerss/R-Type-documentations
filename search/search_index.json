{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"R-Type Networked"},{"location":"#overview","title":"Overview","text":"<p>R-Type is a horizontally scrolling shooter arcade video game developed and released by Irem in 1987 and the first game in the R-Type series. The player controls a star ship, the R-9 \"Arrowhead\", in its efforts to destroy the Bydo, a powerful alien race bent on wiping out all of mankind.</p> <p>Source: Wikipedia</p>"},{"location":"#installation","title":"Installation","text":"<p>Installation process uses vcpkg to install its depedencies.</p> <p>We provided Installation scripts to help you install everything.</p> <p>Simply run <code>install.sh</code> on Linux or <code>install.bat</code> on Windows.</p> <p>To compile the programs <code>r-type_client</code> and <code>r-type_server</code>:</p> <pre><code>  $&gt; cmake -S . -B Build/\n  $&gt; make -C Build/ -j\n</code></pre> <p>Note: Make sure you are under the root directory before running the compilation commands.</p>"},{"location":"#tech-stack","title":"Tech Stack","text":"<p>Both programs use C++</p> <p>Client: SFML</p> <p>Server: Asio</p> <p>Note: Has it is required to communicate with the server, the client also uses Asio.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentations can be found here</p>"},{"location":"#license","title":"License","text":""},{"location":"#authors","title":"Authors","text":"<ul> <li>@Divengerss</li> <li>@M4KS0U</li> <li>@JulianEmr</li> <li>@JulesLevi</li> </ul>"},{"location":"client/","title":"Client documentation","text":"<p>Coming soon</p>"},{"location":"Server/architecture/","title":"Architecture","text":"<p>The server should be self-explanatory when reading the source code, nevertheless, this documentation provides more details about the server workflow.</p> <p>The server uses Asio non-boost C++20 to run.</p> <p>Every network codes are under the <code>net</code> namespace included in the <code>Netcode.hpp</code>.</p> <p>To instantiate a new server, simply call the <code>Server</code> class constructor and calls <code>startServer()</code> to start the server. Just by doing that will run your server properly. However, you need to keep your program open or the server will close itself if the main returns.</p> <p>Here is an example of implementation</p> <pre><code>#include \"Netcode.hpp\"\n\nint main()\n{\n    asio::io_context ioContext;\n    asio::io_service ioService;\n\n    net::Server server(ioContext, ioService);\n\n    server.startServer();\n\n    while (true) {\n        // Game logics\n    }\n}\n</code></pre> <p>The server constructor needs an Asio context and service. Those are used to run the network context and service from Asio.</p> <p>Simply instanciate and pass them to the ctor.</p>"},{"location":"Server/architecture/#cfg-config-files","title":"CFG Config files","text":"<p>The configuration file is required to run the server with modified settings. It provides the host and port to listen to.</p> <p>Here is the <code>server.cfg</code> file located inside the <code>Release</code> directory.</p> <pre><code># Server config file\n\n# IP Address to connect to\nhost=127.0.0.1\n\n# Port of the host to connect to\nport=12346\n</code></pre>"},{"location":"Server/architecture/#constructorsdestructors","title":"Constructors/Destructors","text":""},{"location":"Server/architecture/#server-default-ctor","title":"Server default ctor","text":"<p><code>Server() = delete</code></p> <p>The default constructor of the Server class is deleted to allow better workflow.</p>"},{"location":"Server/architecture/#server-ctor","title":"Server ctor","text":"<p><code>Server(asio::io_context &amp;ioContext, asio::io_context &amp;ioService)</code></p> <p>Server class ctor, requires an Asio context as <code>asio::io_context</code> and an Asio server as <code>asio::io_context</code>. The ctor will seek a <code>.cfg</code> file for its configuration as mention before. If the file format is corrupted, a value can't be found or the file is missing, the default values are applied. If unchanged in the code, they will be 127.0.0.1 for the host and 12346 for the port number</p>"},{"location":"Server/architecture/#server","title":"~Server","text":"<p><code>~Server()</code></p> <p>The <code>Server</code> class destructor.</p>"},{"location":"Server/architecture/#getters","title":"Getters","text":""},{"location":"Server/architecture/#getiocontext","title":"getIoContext","text":"<p><code>asio::io_context &amp;getIoContext() const noexcept</code></p> <p>Returns the Asio IO context.</p>"},{"location":"Server/architecture/#getioservice","title":"getIoService","text":"<p><code>asio::io_context &amp;getIoService() const noexcept</code></p> <p>Returns the Asio IO Serivice.</p>"},{"location":"Server/architecture/#gethost","title":"getHost","text":"<p><code>const std::string &amp;getHost() const noexcept</code></p> <p>Returns the Host string.</p>"},{"location":"Server/architecture/#getport","title":"getPort()","text":"<p><code>std::uint16_t getPort() const noexcept</code></p> <p>Returns the Port number as an unsigned 16bits integer</p>"},{"location":"Server/architecture/#getserverendpoint","title":"getServerEndpoint","text":"<p><code>const asio::ip::udp::endpoint &amp;getServerEndpoint() const noexcept</code></p> <p>Returns the server endpoint, the endpoint corresponds to the communication terminaison of the server.</p>"},{"location":"Server/architecture/#getsocket","title":"getSocket","text":"<p><code>const asio::ip::udp::socket &amp;getSocket() const noexcept</code></p> <p>Returns the server socket.</p>"},{"location":"Server/architecture/#getasioerrorcode","title":"getAsioErrorCode","text":"<p><code>const asio::error_code &amp;getAsioErrorCode() const noexcept</code></p> <p>Returns the Asio error code. This value is set whenever an error occures in the Asio context.</p>"},{"location":"Server/architecture/#getclients","title":"getClients","text":"<p><code>const std::unordered_map&lt;std::string, asio::ip::udp::endpoint&gt; &amp;getClients() const noexcept</code></p> <p>Returns the connected clients list as an unordered map. The key corresponds to the UUID of the client and the value its endpoint.</p>"},{"location":"Server/architecture/#setters","title":"Setters","text":""},{"location":"Server/architecture/#sethost","title":"setHost","text":"<p><code>void setHost(const std::string &amp;host)</code></p> <p>Sets the server host.</p>"},{"location":"Server/architecture/#setport","title":"setPort","text":"<p><code>void setPort(std::uint16_t port)</code></p> <p>Sets the server port</p>"},{"location":"Server/architecture/#setconnection","title":"setConnection","text":"<p><code>void setConnection(const std::string &amp;host, std::uint16_t port)</code></p> <p>Sets the server host and port, This calls to the <code>setHost</code> and <code>setPort</code>.</p>"},{"location":"Server/architecture/#setserverinstance","title":"setServerInstance","text":"<p><code>static void setServerInstance(Server* instance)</code></p> <p>Set the static variable <code>serverInstance</code> used to access class elements from the IO Service, mainly used to handle CTRL-C event.</p>"},{"location":"Server/architecture/#setpacket","title":"setPacket","text":"<p><code>void setPacket(T &amp;packet, packet::packetHeader &amp;header, T &amp;data)</code></p> <p>Sets the packet from a <code>typename T</code> template packet, the packet header and its data. This function will memory copy the <code>header</code> and <code>data</code> into the <code>packet</code>. The packet must be large enough to hold the header + data sizes.</p>"},{"location":"Server/architecture/#fillbufferfromrequest","title":"fillBufferFromRequest","text":"<p><code>void fillBufferFromRequest(T &amp;packet, std::size_t size)</code></p> <p>Fills the <code>packet</code> given as parameter from the private variable <code>_packet</code> of the <code>Server</code> class. This function will memory copy into <code>packet</code>.</p>"},{"location":"Server/architecture/#sendresponse","title":"sendResponse","text":"<p><code>void sendResponse(const packet::packetTypes &amp;type, T &amp;packet, const std::string cliUuid = \"\")</code></p> <p>Builds a packet and sends it to all the clients if no <code>cliUuid</code> are provided. The <code>packet</code> must not contains any header as it is generated using the <code>type</code> variable and the size of packet. If the <code>cliUuid</code> is set, the packet will only be sent to the given client UUID. If the UUID is invalid or doesn't link to a valid client, the packet remains unsent.</p>"},{"location":"Server/architecture/#handlerequeststatus","title":"handleRequestStatus","text":"<p><code>void handleRequestStatus()</code></p> <p>Handles each packets type.</p>"},{"location":"Server/architecture/#handlereceivefrom","title":"handleReceiveFrom","text":"<p><code>void handleReceiveFrom(const asio::error_code &amp;errCode, std::size_t bytesReceived)</code></p> <p>Handles the received packet type. This function is called from the asynchronous receiver function from Asio <code>socket.async_receive_from</code>.</p>"},{"location":"Server/architecture/#receive","title":"receive","text":"<p><code>void receive()</code></p> <p>Start the asynchronous receive operations.</p>"},{"location":"Server/architecture/#startserver","title":"startServer","text":"<p><code>void startServer()</code></p> <p>Start the server and calls everything required. This function should be the only one called outside.</p>"},{"location":"Server/architecture/#signalhandler","title":"signalHandler","text":"<p><code>static void signalHandler(int signum)</code></p> <p>Handles the signal events.</p>"},{"location":"Server/architecture/#addclient","title":"addClient","text":"<p><code>std::string addClient()</code></p> <p>Adds a new client to the client lists and returns its new UUID.</p>"},{"location":"Server/Protocol/binary_protocol/","title":"Binary protocol","text":"<p>Communication between the server and the players/clients is done using binary packets.</p> <p>A packet on its own contains a header and its data to transmit. The header contains the type of packet sent and the size of the following data. By default (if unchanged in the code) the packet size locally is limited to 1024 bytes.</p> <p>Here is the packet header structure defined in the Packet.hpp</p> <pre><code>struct packetHeader\n{\n    packetTypes type;\n    std::uint16_t dataSize;\n\n    packetHeader() : type(PLACEHOLDER), dataSize(0) {}\n    packetHeader(packetTypes type, std::uint16_t dataSize) : type(type), dataSize(dataSize) {}\n};\n</code></pre> <p>This can be interpreted as the following pseudo-code</p> <pre><code>HEADER\n{\n    INTEGER type\n    16BIT UNSIGNED INTEGER size_of_the_data\n}\n</code></pre> <p>The <code>packetTypes type</code> refers to the following <code>Enum</code></p> <pre><code>enum packetTypes\n{\n    PLACEHOLDER,\n    CONNECTION_REQUEST,\n    DISCONNECTION_REQUEST,\n};\n</code></pre> <p>The <code>std::uint16_t dataSize</code> stores an unsigned 16bits integer refering to the packet data size to be read from the recipient. Data must be strictly identical to the data size, if the value if lower than its actual size, it will be truncated, leading to undefined behavior. If the value is greather than its actual size, it will mostly crash or leads to buffer overflow, leading to undefined behavior. If the type is set to <code>PLACEHOLDER</code>, no data is expected to be read, setting the <code>dataSize</code> to 0.</p> <p>Packet header contains contructors to initialize the header with given values.</p> <p>Packet lists:</p> <ul> <li>Connection request</li> <li>Disconnection request</li> </ul>"},{"location":"Server/Protocol/Packets/connection_request/","title":"Connection request","text":"<p>Type <code>CONNECTION_REQUEST</code></p> <pre><code>struct connectionRequest\n{\n    std::uint8_t status;\n    std::array&lt;std::uint8_t, UUID_SIZE&gt; uuid;\n\n    connectionRequest() : status(REQUEST)\n    {\n        std::memset(&amp;uuid, 0, UUID_SIZE);\n    }\n    connectionRequest(uint8_t status, const std::string &amp;cliUuid) : status(status)\n    {\n        std::memcpy(&amp;uuid, cliUuid.data(), UUID_SIZE);\n    }\n};\n</code></pre> <p>The connection request packet asks the server if the client can connect to the server. The client is not expected to provide anything upon sending the packet, however, the packet type must be revelant in the header.</p> <p>The <code>std::uint8_t status</code> refers to the server response and so, doesn't need to be set from the client. The server will response with <code>ACCEPTED</code> anyway, as the connection will always be valid, even if the client is already connected to the server. It is the client job to check if he already has an open connection with the server.</p> <p>When receiving the packet response from the server, the <code>dataSize</code> should be set to <code>UUID_SIZE</code>, or 37 bits (is unchanged in the code) containing the UUID the client holds on the server. This Universally Unique Identifier must be used from now to send any packets to the server, if no UUID are provided, the server will refuse them.</p> <p>The UUID represent a string as follow: <code>XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code></p>"},{"location":"Server/Protocol/Packets/disconnection_request/","title":"Disconnection request","text":"<p>Type <code>DISCONNECTION_REQUEST</code></p> <pre><code>struct disconnectionRequest\n{\n    std::uint8_t status;\n    std::array&lt;packetTypes, UUID_SIZE&gt; uuid;\n\n    disconnectionRequest(const std::string &amp;cliUuid) : status(REQUEST)\n    {\n        std::memcpy(&amp;uuid, cliUuid.data(), UUID_SIZE);\n    }\n    disconnectionRequest(uint8_t status) : status(status) {}\n};\n</code></pre> <p>The disconnection packet tells the server the client disconnected from it. No response should be expected from the server and the client must not send anything from now as the server will reject everything unless the client resends a connection request packet.</p> <p>The client must send its UUID with the packet and the header type must be <code>DISCONNECTION_REQUEST</code></p>"}]}